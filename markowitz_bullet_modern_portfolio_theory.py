# -*- coding: utf-8 -*-
"""Markowitz_bullet_modern_portfolio_theory.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kK0PgE98mnJ3GdLLvihHH24H-Y2_Hjl1
"""

from google.colab import drive
drive.mount('/content/drive')

#import numpy and pandas
import pandas as pd
import numpy as np

"""My porfolio comprised of {Cipla, ICICI, Sunpharma, SBIN, Vedl}

Used the equity data for the time period od Mar'19-Mar'20, for 245 working days.
"""

#loading cipla data
cipla = pd.read_csv("/content/drive/My Drive/Colab Notebooks/markowitz_bullet/cipla.csv",usecols=['Close Price'])
cipla.head()
cipla.shape

#loading icici data
icici = pd.read_csv("/content/drive/My Drive/Colab Notebooks/markowitz_bullet/ICICIBANK.csv",usecols=['Close Price'])
icici.head()
icici.shape

#loading sbin data
sbin = pd.read_csv("/content/drive/My Drive/Colab Notebooks/markowitz_bullet/SBIN.csv",usecols=['Close Price'])
sbin.head()
sbin.shape

#loading sunpharma data
sunpharma = pd.read_csv("/content/drive/My Drive/Colab Notebooks/markowitz_bullet/SUNPHARMA.csv",usecols=['Close Price'])
sunpharma.head()
sunpharma.shape

#loading Vedl data
vedl = pd.read_csv("/content/drive/My Drive/Colab Notebooks/markowitz_bullet/VEDL.csv",usecols=['Close Price'])
vedl.head()
vedl.shape

#concating all the datasets into single dataframe

stocks=pd.concat([cipla,vedl,sunpharma,sbin,icici],axis=1)
stocks.columns=['cipla','vedl','sunpharma','sbin','icici']
stocks.head()

#calculating the logarithmic return
log_ret = np.log(stocks/stocks.shift(1))
log_ret.head()

#making random seed for finding the weights
np.random.seed(42)

#number of iterations
num_ports = 20000

#intializing the weigths with zero
all_weights = np.zeros((num_ports, len(stocks.columns)))

#intializing the return, volatility, and sharpe ratio array with zero
ret_arr = np.zeros(num_ports)
vol_arr = np.zeros(num_ports)
sharpe_arr = np.zeros(num_ports)

#iterating over num_ports
for x in range(num_ports):
    # Weights
    weights = np.array(np.random.random(5))
    weights = weights/np.sum(weights)
    
    # Save weights
    all_weights[x,:] = weights
    
    # Expected return
    ret_arr[x] = np.sum( (log_ret.mean() * weights))
    
    # Expected volatility
    vol_arr[x] = np.sqrt(np.dot(weights.T, np.dot(log_ret.cov(), weights)))
    
    # Sharpe Ratio
    sharpe_arr[x] = ret_arr[x]/vol_arr[x]

print('Max sharpe ratio in the array: {}'.format(sharpe_arr.max()))
print('Its location in the array: {}'.format(sharpe_arr.argmax()))
print('Max log return in the array: {}'.format(ret_arr[sharpe_arr.argmax()]))
print('vol for Max log return in the array: {}'.format(vol_arr[sharpe_arr.argmax()]))

print('Min volatality in the array: {}'.format(vol_arr.min()))
print('Its location in the array: {}'.format(vol_arr.argmin()))
print('MIN VOLATILE log return in the array: {}'.format(ret_arr[vol_arr.argmin()]))
print('MIN vol log return in the array: {}'.format(vol_arr[vol_arr.argmin()]))
print('sharpe ratio FOR MIN VOL in the array: {}'.format(sharpe_arr[vol_arr.argmin()]))

#weights with maximum sharpe ratio
print(all_weights[13487,:])

max_sr_ret=ret_arr[sharpe_arr.argmax()]
max_sr_vol=vol_arr[sharpe_arr.argmax()]

#weights with minimum sharpe ratio
print(all_weights[11557,:])

min_vol_ret=ret_arr[vol_arr.argmin()]
min_vol=vol_arr[vol_arr.argmin()]

#ploting the markowitz bullets
import matplotlib.pyplot as plt

plt.figure(figsize=(12,8))
plt.scatter(vol_arr, ret_arr, c=sharpe_arr, cmap='viridis')
plt.colorbar(label='Sharpe Ratio')
plt.xlabel('Volatility')
plt.ylabel('Return')
plt.scatter(max_sr_vol, max_sr_ret,c='red',marker="*", s=250) # red star
plt.scatter(min_vol, min_vol_ret,c='red',marker="*", s=250) # red star
plt.xlim(0.011, 0.023)
plt.ylim(-0.0015, 0.0010)
plt.show()

#getting return, volatility and sharpe ratio for the given weights
def get_ret_vol_sr(weights):
    weights = np.array(weights)
    ret = np.sum(log_ret.mean() * weights)
    vol = np.sqrt(np.dot(weights.T, np.dot(log_ret.cov(), weights)))
    sr = ret/vol
    return np.array([ret, vol, sr])

def neg_sharpe(weights):
# the number 2 is the sharpe ratio index from the get_ret_vol_sr
    return get_ret_vol_sr(weights)[2] * -1

#checking if the weeights are valid or not
def check_sum(weights):
    #return 0 if sum of the weights is 1
    return np.sum(weights)-1

cons = ({'type' : 'eq', 'fun':check_sum})
bounds=((0,1),(0,1),(0,1),(0,1),(0,1))
init_guess = [0.25,0.25,0.25,0.25,0.25]

#creating the best fit curve around the bullets to enclose in a parabola
from scipy.optimize import minimize

#used SLSQP optimizer- sequential least squares programming as the method for minimizing the best fit curve while optimizing the intial guess
opt_results = minimize(neg_sharpe,init_guess,method='SLSQP',bounds=bounds,constraints=cons)
print(opt_results)

get_ret_vol_sr(opt_results.x)

frontier_y=np.linspace(0,0.001,200)

def minimize_volatility(weights):
    return get_ret_vol_sr(weights)[1]

frontier_x = []

for possible_return in frontier_y:
    cons = ({'type':'eq', 'fun':check_sum},
            {'type':'eq', 'fun': lambda w: get_ret_vol_sr(w)[0] - possible_return})
    
    result = minimize(minimize_volatility,init_guess,method='SLSQP', bounds=bounds, constraints=cons)
    frontier_x.append(result['fun'])

plt.figure(figsize=(12,8))
plt.scatter(vol_arr, ret_arr, c=sharpe_arr, cmap='viridis')
plt.colorbar(label='Sharpe Ratio')
plt.xlabel('Volatility')
plt.ylabel('Return')
plt.plot(frontier_x,frontier_y, 'r--', linewidth=3)

#point with maximum sharpe ratio
plt.scatter(max_sr_vol, max_sr_ret,c='red',marker="*", s=350) # red star

#point with minimum volatility
plt.scatter(min_vol, min_vol_ret,c='green',marker="*", s=350) # green star
plt.xlim(0.011, 0.023)
plt.ylim(-0.0015, 0.0010)
plt.savefig('/content/drive/My Drive/Colab Notebooks/markowitz_bullet/markowitz_bullets.png')
plt.show()

